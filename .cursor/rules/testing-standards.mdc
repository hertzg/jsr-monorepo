---
description: Enforce comprehensive testing standards and patterns for Deno projects
globs: ["**/*.test.ts", "**/examples.test.ts", "**/mod.test.ts"]
alwaysApply: true
---

# Testing Standards

## Core Requirements

- Use `Deno.test()` for test organization
- Use `Deno.test()` with descriptive names for test cases
- Use `await t.step()` for sub-tests
- All tests use `assertEquals`, `assertThrows`, `assertExists`, `assertRejects`,
  etc. from `@std/assert`
- Test both positive and negative cases
- Include comprehensive test coverage for all functionality
- Test all public APIs
- Include edge cases and error conditions
- Use descriptive test names
- Group related tests logically
- Verify round-trip when it makes sense
- Include performance-critical path tests

## Test Structure & Organization

### Basic Test Structure

```typescript
Deno.test("isValidLength", () => {
  // Valid lengths
  assertEquals(isValidLength(0), true);
  assertEquals(isValidLength(1), true);
  assertEquals(isValidLength(100), true);

  // Invalid lengths
  assertEquals(isValidLength(-1), false);
  assertEquals(isValidLength(1.5), false);
  assertEquals(isValidLength(NaN), false);
});
```

### Complex Test with Sub-tests

```typescript
Deno.test("binary encoding/decoding", async (t) => {
  await t.step("basic encoding", () => {
    const coder = u16le();
    const buffer = new Uint8Array(2);
    const bytesWritten = coder.encode(42, buffer);
    assertEquals(bytesWritten, 2);
  });

  await t.step("round-trip integrity", () => {
    const coder = u16le();
    const originalValue = 12345;
    const buffer = new Uint8Array(2);

    const bytesWritten = coder.encode(originalValue, buffer);
    const [decodedValue, bytesRead] = coder.decode(buffer);

    assertEquals(bytesRead, bytesWritten);
    assertEquals(decodedValue, originalValue);
  });

  await t.step("error handling", () => {
    const coder = u16le();
    const buffer = new Uint8Array(1); // Too small

    assertThrows(() => {
      coder.encode(65535, buffer);
    }, RangeError);
  });
});
```

## File Organization

- Separate test files with `.test.ts` suffix
- Use `mod.test.ts` for main usage examples
- Use `examples.test.ts` for comprehensive usage demonstrations
- Group related tests logically
- Use descriptive names for test cases
- JSDoc examples are also tested and must pass

## Test Categories

### Unit Tests

- Test individual functions and methods
- Focus on specific functionality
- Include edge cases and error conditions
- Verify input validation and output correctness

### Integration Tests

- Test component interactions
- Verify data flow between modules
- Test error propagation
- Validate API contracts

### Round-trip Tests

- Essential for binary encoding/decoding
- Verify data integrity through encode/decode cycles
- Test with various data types and sizes
- Ensure no data loss or corruption

### Performance Tests

- Test performance-critical paths
- Measure encoding/decoding speed
- Verify memory usage patterns
- Include benchmarks for optimization validation

## Assertion Patterns

### Data Integrity

```typescript
// Verify round-trip data integrity
assertEquals(decodedValue, originalValue);
assertEquals(bytesRead, bytesWritten);
```

### Error Handling

```typescript
// Test expected exceptions
assertThrows(() => {
  invalidOperation();
}, SpecificError);

// Test async error handling
await assertRejects(async () => {
  await asyncInvalidOperation();
}, SpecificError);
```

## Testing & Linting Requirements

### Core Requirements

- **ALWAYS** run `deno task lint` and `deno task test` at the root of the
  project at the very end of any development work
- These commands must be executed before considering any task complete
- All code changes must pass both linting and testing before being finalized
- No code should be considered production-ready without passing these checks

### Command Execution

#### Development Commands (Faster Feedback)

For faster development feedback, you can run these commands in individual
workspaces:

```bash
# Run in individual workspace directories for faster feedback
deno test
deno test --doc
deno lint
```

#### Final Required Commands (Mandatory)

**ALWAYS** run these commands at the project root before completing any task:

```bash
# Run from project root - MANDATORY final check
deno task lint
deno task test
```

#### Command Details

- **Development commands**: Faster feedback loop during development
- **Final commands**: Comprehensive validation with import map checking,
  coverage, leak detection, and parallel execution
- Both final commands must complete successfully with exit code 0

### Workflow Integration

#### When to Run

**Development Commands (Workspace Level):**

- During active development for faster feedback
- When testing specific functionality
- For quick validation of changes

**Final Commands (Project Root):**

- **Before completing any coding task**
- **After making any code changes**
- **Before committing code changes**
- **As the final step in any development session**
- **When fixing bugs or implementing features**

#### Execution Order

**During Development:**

1. Make code changes
2. Run workspace-level commands for quick feedback (`deno test`, `deno lint`)
3. Fix issues and iterate

**Final Validation:**

1. Complete all code changes
2. Run `deno task lint` from project root
3. Fix any linting issues if they occur
4. Run `deno task test` from project root
5. Fix any test failures if they occur
6. Repeat steps 2-5 until both commands pass
7. Only then consider the task complete

### Quality Assurance

#### Linting Checks

- Code style compliance
- Import map validation
- TypeScript type checking
- Best practice enforcement
- Security vulnerability detection

#### Testing Checks

- All unit tests pass
- Integration tests pass
- JSDoc examples execute successfully
- Coverage requirements met
- Memory leak detection
- Performance benchmarks

### Error Handling

#### If Linting Fails

- Review and fix all linting errors
- Address import map issues
- Ensure proper code formatting
- Re-run `deno task lint` until it passes

#### If Testing Fails

- Review test failures and error messages
- Fix broken functionality
- Update tests if requirements changed
- Ensure JSDoc examples are executable
- Re-run `deno task test` until it passes

## Best Practices

- **Comprehensive Coverage**: Test all public APIs and edge cases
- **Realistic Data**: Use meaningful test data that reflects real-world usage
- **Clear Intent**: Test names should clearly describe what is being tested
- **Isolation**: Each test should be independent and not rely on other tests
- **Performance Awareness**: Include tests for performance-critical operations
- **Documentation**: Treat tests as living documentation of expected behavior
- **Quality Gates**: Always run linting and testing commands before finalizing
  work
- **Continuous Validation**: Use these commands as mandatory quality assurance
  steps
