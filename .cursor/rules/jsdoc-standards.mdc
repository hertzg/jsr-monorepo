---
description: Enforce comprehensive JSDoc standards for all exported members
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
---

# JSDoc Documentation Standards

## Core Requirements

- **ALL exported members MUST have JSDoc documentation**
- Each named export MUST have its own `@module` level JSDoc
- Always include `@example` unless redundant or doesn't add clarity
- Each `@example` MUST use `assert*` functions to verify the example code
- **AVOID** `console.log` and comments in examples
- Treat JSDoc examples as executable code - they are tested during `test` task
- Use `assertEquals`, `assertThrows`, etc. from `@std/assert` in examples
- Examples must be comprehensive and demonstrate real-world usage
- Include multiple examples for complex functions showing different use cases

## Documentation Structure

### Function Documentation

- Every function must have JSDoc with description
- Document all parameters with `@param` tags
- Document return values with `@returns` tags
- Include `@example` blocks with assertions
- Use descriptive parameter names in JSDoc

### Type Documentation

- Use descriptive type names with proper JSDoc
- Include `@template` tags for generic types
- Document all type parameters and their constraints
- Use `export type` for type-only exports

### Module Documentation

- Main module exports (`mod.ts`) have comprehensive module-level JSDoc
- Use `@module` tag at the end of module documentation
- Export types, functions, and symbols with proper JSDoc

## Example Quality Standards

- Examples must be executable and verifiable
- Use realistic data and scenarios
- Include multiple examples for complex functions
- Show both encoding and decoding operations
- Verify data integrity with assertions
- Include error cases when relevant
- Use meaningful variable names in examples

### ✅ GOOD Example

````typescript
/**
 * Creates a refiner that transforms ISO date strings to and from Date objects.
 *
 * @param baseCoder The base string coder to refine
 * @param options Configuration object with encode/decode functions
 * @returns A refined coder that works with Date objects
 *
 * @example Refining an ISO date string to and from a Date object
 * ```ts
 * import { assertEquals } from "@std/assert";
 * import { string, refine } from "@hertzg/binstruct";
 *
 * const isoDateString = refine(string(), {
 *   decode: (decoded: string) => new Date(decoded),
 *   encode: (refined: Date) => refined.toISOString(),
 * });
 *
 * const dateCoder = isoDateString();
 * const testDate = new Date("2025-08-22T00:00:00Z");
 * const buffer = new Uint8Array(100);
 *
 * const bytesWritten = dateCoder.encode(testDate, buffer);
 * const [decodedDate, bytesRead] = dateCoder.decode(buffer);
 *
 * assertEquals(bytesRead, bytesWritten);
 * assertEquals(decodedDate.getTime(), testDate.getTime());
 * ```
 */
````

### ❌ BAD Example

````typescript
/**
 * @example
 * ```ts
 * import { assertEquals } from "@std/assert";
 * import { struct, u16le, u8le } from "@hertzg/binstruct";
 *
 * const coder = struct({ id: u16le(), flag: u8le() });
 * const value = { id: 513, flag: 7 };
 * const buf = new Uint8Array(32);
 * const written = coder.encode(value, buf);
 * const [decoded, read] = coder.decode(buf);
 *
 * assertEquals(decoded, value);
 * assertEquals(written, read);
 * ```
 */
````

## Common Patterns

### Binary Data Operations

- Always document buffer size requirements
- Show both encoding and decoding in examples
- Verify round-trip data integrity
- Use realistic data sizes and values

### Error Handling

- Include examples that demonstrate error cases
- Use `assertThrows` for expected exceptions
- Show proper error handling patterns

### Performance Considerations

- Document performance characteristics when relevant
- Include examples with appropriate data sizes
- Mention any limitations or constraints
