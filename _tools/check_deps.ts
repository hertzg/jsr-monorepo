/**
 * Validates or updates dependency snapshots for all workspace packages.
 *
 * Each package gets a `_deps.snap` file with a clean JSON structure showing
 * external dependencies for each entrypoint.
 *
 * Usage:
 *   deno run -A _tools/check_deps.ts          # Check snapshots
 *   deno run -A _tools/check_deps.ts --update # Update snapshots
 *
 * @module
 */

import { join, toFileUrl } from "@std/path";
import denoJson from "../deno.json" with { type: "json" };

interface DenoInfoDependency {
  specifier: string;
  code?: { specifier: string };
  type?: { specifier: string };
}

interface DenoInfoModule {
  specifier: string;
  dependencies?: DenoInfoDependency[];
}

interface DenoInfoOutput {
  roots: string[];
  modules: DenoInfoModule[];
  npmPackages?: Record<string, { name: string; version: string }>;
}

interface PackageJson {
  name: string;
  version: string;
  exports: Record<string, string> | string;
}

interface DepsSnapshot {
  __autogenerated: string;
  deps: Record<string, string[]>;
}

async function getDenoInfo(modulePath: string): Promise<DenoInfoOutput> {
  const command = new Deno.Command("deno", {
    args: ["info", "--json", modulePath],
    stdout: "piped",
    stderr: "piped",
  });

  const { stdout } = await command.output();
  return JSON.parse(new TextDecoder().decode(stdout));
}

async function getDepsForPackage(
  rootPath: string,
  workspacePath: string,
): Promise<DepsSnapshot> {
  const pkgJsonUrl = toFileUrl(join(rootPath, workspacePath, "deno.json"));
  const pkgJson: PackageJson =
    (await import(pkgJsonUrl.href, { with: { type: "json" } })).default;

  const exports = typeof pkgJson.exports === "string"
    ? { ".": pkgJson.exports }
    : pkgJson.exports;

  const fullWorkspacePath = join(rootPath, workspacePath);
  const workspacePathUrl = toFileUrl(fullWorkspacePath);

  const depsSnapshot: DepsSnapshot = {
    __autogenerated:
      "This file is auto-generated. Do not edit manually. Run: deno run -A _tools/check_deps.ts --update",
    deps: {},
  };

  for (const [mod, path] of Object.entries(exports)) {
    const entrypointPath = join(fullWorkspacePath, path);

    const info = await getDenoInfo(entrypointPath);
    const workspaceModules = info.modules.filter((m) =>
      m.specifier.startsWith(workspacePathUrl.href)
    );

    const deps = workspaceModules
      .filter((m) => m.specifier.startsWith(`file://${rootPath}`))
      .flatMap((m) => m.dependencies ?? [])
      .map((d) => ({
        source: d.specifier,
        resolved: d.code?.specifier ?? d.type?.specifier ?? d.specifier,
      }))
      .filter(({ source, resolved }) => {
        if (source.startsWith(".")) return false;
        if (resolved.startsWith(workspacePathUrl.href)) return false;
        return true;
      })
      .map(({ source, resolved }) => {
        if (resolved.startsWith("file://")) {
          return source;
        }
        return resolved;
      });

    depsSnapshot.deps[mod] = Array.from(new Set(deps)).sort();
  }

  return depsSnapshot;
}

const rootPath = join(import.meta.dirname!, "../");
const updateMode = Deno.args.includes("--update");

let failed = false;
let updated = 0;

for (const workspacePath of denoJson.workspace) {
  const pkgJsonUrl = toFileUrl(join(rootPath, workspacePath, "deno.json"));
  const pkgJson: PackageJson =
    (await import(pkgJsonUrl.href, { with: { type: "json" } })).default;

  const snapshotPath = join(rootPath, workspacePath, "_deps.snap");
  const currentSnapshot = await getDepsForPackage(rootPath, workspacePath);

  if (updateMode) {
    await Deno.writeTextFile(
      snapshotPath,
      JSON.stringify(currentSnapshot, null, 2) + "\n",
    );
    updated++;
    continue;
  }

  let existingSnapshot: DepsSnapshot | null = null;
  try {
    existingSnapshot = JSON.parse(await Deno.readTextFile(snapshotPath));
  } catch {
    console.warn(`check_deps: ${pkgJson.name}: missing _deps.snap`);
    failed = true;
    continue;
  }

  const currentStr = JSON.stringify(currentSnapshot.deps);
  const existingStr = JSON.stringify(existingSnapshot.deps);

  if (currentStr !== existingStr) {
    console.warn(`check_deps: ${pkgJson.name}: deps mismatch`);
    for (const [mod, deps] of Object.entries(currentSnapshot.deps)) {
      const existingDeps = existingSnapshot.deps[mod] ?? [];
      if (JSON.stringify(deps) !== JSON.stringify(existingDeps)) {
        console.warn(`  [${mod}]:`);
        console.warn(`    expected: ${JSON.stringify(existingDeps)}`);
        console.warn(`    actual:   ${JSON.stringify(deps)}`);
      }
    }
    failed = true;
  }
}

if (updateMode) {
  console.log(`check_deps: updated ${updated} snapshots`);
} else if (failed) {
  console.warn(
    "\nRun 'deno run -A _tools/check_deps.ts --update' to update snapshots.",
  );
  Deno.exit(1);
} else {
  console.log("check_deps: ok");
}
